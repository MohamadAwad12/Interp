<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Table Interpolation Tool - CE2070</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --success: #10b981;
            --error: #ef4444;
            --warning: #f59e0b;
            --text-primary: #111827;
            --text-secondary: #6b7280;
            --border: #e5e7eb;
            --bg: #ffffff;
            --bg-light: #f8fafc;
            --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-light);
            min-height: 100vh;
            color: var(--text-primary);
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px;
        }

        /* Header Section */
        .header {
            background: var(--bg);
            color: var(--text-primary);
            padding: 32px;
            border-radius: 12px;
            margin-bottom: 24px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
        }

        .header h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 8px;
            color: var(--primary);
        }

        .header-subtitle {
            font-size: 1rem;
            color: var(--text-secondary);
            margin-bottom: 16px;
        }

        .header-meta {
            display: flex;
            gap: 24px;
            flex-wrap: wrap;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .header-meta-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* Main Grid Layout */
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            margin-bottom: 24px;
        }

        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Card Component */
        .card {
            background: var(--bg);
            border-radius: 8px;
            padding: 24px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
        }

        .card-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .card-title-icon {
            width: 20px;
            height: 20px;
            background: var(--primary);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
        }

        /* Input Styles */
        .input-group {
            margin-bottom: 16px;
        }

        .input-label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 6px;
        }

        .input-field {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.875rem;
            transition: all 0.2s ease;
            background: var(--bg);
        }

        .input-field:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .input-field:disabled {
            background: var(--bg-light);
            cursor: not-allowed;
            opacity: 0.7;
        }

        /* Button Styles */
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-danger {
            background: var(--error);
            color: white;
        }

        .btn-secondary {
            background: var(--text-secondary);
            color: white;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        /* Data Table */
        .data-table-container {
            overflow-x: auto;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
        }

        .data-table thead {
            background: var(--bg-light);
        }

        .data-table th {
            padding: 12px;
            text-align: left;
            font-weight: 600;
            font-size: 0.875rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 2px solid var(--border-color);
        }

        .data-table td {
            padding: 10px 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .data-table tbody tr:hover {
            background: #f9fafb;
        }

        .data-table tbody tr:last-child td {
            border-bottom: none;
        }

        .table-input {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid transparent;
            border-radius: 4px;
            font-size: 0.95rem;
            transition: all 0.2s ease;
            background: transparent;
        }

        .table-input:focus {
            outline: none;
            border-color: #0083b0;
            background: white;
            box-shadow: 0 0 0 2px rgba(0, 131, 176, 0.1);
        }

        .table-input:invalid {
            border-color: var(--error-color);
        }

        /* Upload Zone */
        .upload-zone {
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            padding: 40px 20px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            background: var(--bg-light);
            position: relative;
            overflow: hidden;
        }

        .upload-zone:hover {
            border-color: #0083b0;
            background: #f0f9ff;
        }

        .upload-zone.dragover {
            border-color: #0083b0;
            background: #e0f2fe;
        }

        .upload-icon {
            font-size: 3rem;
            margin-bottom: 10px;
            opacity: 0.5;
        }

        .upload-text {
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .upload-hint {
            font-size: 0.875rem;
            color: var(--text-secondary);
            opacity: 0.8;
        }

        /* Statistics Panel */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: var(--bg-light);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .stat-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            color: var(--text-secondary);
            letter-spacing: 0.5px;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        /* Results Display */
        .result-container {
            background: linear-gradient(135deg, #e0f2fe 0%, #bae6fd 100%);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #7dd3fc;
        }

        .result-value {
            font-size: 3rem;
            font-weight: 700;
            color: #0369a1;
            margin: 15px 0;
            text-align: center;
        }

        .result-details {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.875rem;
            color: var(--text-secondary);
            max-height: 300px;
            overflow-y: auto;
            line-height: 1.8;
        }

        .result-details strong {
            color: var(--text-primary);
        }

        /* Chart Container */
        .chart-container {
            position: relative;
            height: 400px;
            margin-top: 20px;
            padding: 20px;
            background: white;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        canvas {
            max-width: 100%;
            height: auto !important;
        }

        /* Alert Messages */
        .alert {
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .alert-success {
            background: #d1fae5;
            color: #065f46;
            border: 1px solid #a7f3d0;
        }

        .alert-error {
            background: #fee2e2;
            color: #991b1b;
            border: 1px solid #fecaca;
        }

        .alert-warning {
            background: #fed7aa;
            color: #92400e;
            border: 1px solid #fdba74;
        }

        .alert-info {
            background: #dbeafe;
            color: #1e40af;
            border: 1px solid #bfdbfe;
        }

        .alert-icon {
            font-size: 1.2rem;
        }

        /* Loading Spinner */
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top-color: #0083b0;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--border-color);
        }

        .tab {
            padding: 10px 20px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-weight: 500;
            color: var(--text-secondary);
            transition: all 0.2s ease;
            position: relative;
        }

        .tab:hover {
            color: var(--text-primary);
        }

        .tab.active {
            color: #0083b0;
            border-bottom-color: #0083b0;
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        /* Error Boundary */
        .error-boundary {
            background: #fef2f2;
            border: 1px solid #fecaca;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }

        .error-boundary h3 {
            color: #b91c1c;
            margin-bottom: 10px;
        }

        /* Export Options */
        .export-menu {
            position: relative;
            display: inline-block;
        }

        .export-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 5px;
            background: white;
            border-radius: 8px;
            box-shadow: var(--shadow-lg);
            min-width: 200px;
            display: none;
            z-index: 1000;
        }

        .export-dropdown.show {
            display: block;
            animation: slideDown 0.2s ease;
        }

        .export-option {
            padding: 12px 16px;
            cursor: pointer;
            transition: background 0.2s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .export-option:hover {
            background: var(--bg-light);
        }

        .export-option:first-child {
            border-radius: 8px 8px 0 0;
        }

        .export-option:last-child {
            border-radius: 0 0 8px 8px;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8rem;
            }

            .stats-grid {
                grid-template-columns: 1fr 1fr;
            }

            .result-value {
                font-size: 2rem;
            }

            .tabs {
                overflow-x: auto;
            }
        }

        /* Performance optimization */
        .hidden {
            display: none !important;
        }

        .visuallyhidden {
            position: absolute;
            width: 1px;
            height: 1px;
            margin: -1px;
            padding: 0;
            overflow: hidden;
            clip: rect(0,0,0,0);
            border: 0;
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .header {
                background: none;
                color: black;
                border: 2px solid black;
            }

            .btn, .upload-zone, .export-menu {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <h1>📊 Data Interpolation Tool</h1>
            <p class="header-subtitle">Extract data from images and interpolate values using AI</p>
            <div class="header-meta">
                <div class="header-meta-item">
                    <span>👨‍💻</span>
                    <span>Mohamad Awad</span>
                </div>
                <div class="header-meta-item">
                    <span>🎓</span>
                    <span>CE2070</span>
                </div>
                <div class="header-meta-item">
                    <span>📅</span>
                    <span id="currentDate"></span>
                </div>
            </div>
        </header>

        <!-- Main Grid -->
        <div class="main-grid">
            <!-- Left Column -->
            <div>
                <!-- Data Input Card -->
                <div class="card">
                    <h2 class="card-title">
                        <span class="card-title-icon">📥</span>
                        Data Input
                    </h2>

                    <!-- Tabs -->
                    <div class="tabs">
                        <button class="tab active" onclick="switchTab('upload')">Upload Image</button>
                        <button class="tab" onclick="switchTab('manual')">Manual Entry</button>
                        <button class="tab" onclick="switchTab('import')">Import Data</button>
                        <button class="tab" onclick="switchTab('demo')">Demo Sets</button>
                    </div>

                    <!-- Tab Contents -->
                    <div id="upload-tab" class="tab-content active">
                        <div class="upload-zone" onclick="document.getElementById('fileInput').click()" ondrop="handleDrop(event)" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                            <div class="upload-icon">📸</div>
                            <div class="upload-text">Drop image here or click to upload</div>
                            <div class="upload-hint">Supports JPG, PNG, PDF • Max 10MB</div>
                        </div>
                        <input type="file" id="fileInput" accept="image/*,.pdf" class="visuallyhidden">
                        
                        <div class="input-group" style="margin-top: 15px;">
                            <label class="input-label">OpenAI API Key</label>
                            <input type="password" class="input-field" id="apiKeyInput" placeholder="sk-..." style="margin-bottom: 10px;">
                            <button class="btn btn-primary" id="extractButton" onclick="extractDataFromImage()" style="width: 100%;" disabled>
                                🤖 Extract Data with AI
                            </button>
                        </div>
                    </div>

                    <div id="manual-tab" class="tab-content">
                        <div class="input-group">
                            <label class="input-label">Quick Add Point</label>
                            <div style="display: flex; gap: 10px;">
                                <input type="number" class="input-field" id="quickX" placeholder="X value" step="any">
                                <input type="number" class="input-field" id="quickY" placeholder="Y value" step="any">
                                <button class="btn btn-primary" onclick="quickAddPoint()">Add</button>
                            </div>
                        </div>
                    </div>

                    <div id="import-tab" class="tab-content">
                        <div class="input-group">
                            <label class="input-label">Paste CSV/TSV Data</label>
                            <textarea class="input-field" id="csvInput" rows="5" placeholder="x,y&#10;1,2&#10;3,4"></textarea>
                            <button class="btn btn-primary" style="margin-top: 10px;" onclick="importCSV()">Import CSV</button>
                        </div>
                    </div>

                    <div id="demo-tab" class="tab-content">
                        <div class="btn-group">
                            <button class="btn btn-secondary" onclick="loadDemoData('water')">💧 Water Density</button>
                            <button class="btn btn-secondary" onclick="loadDemoData('steel')">🔧 Steel Properties</button>
                            <button class="btn btn-secondary" onclick="loadDemoData('air')">🌡️ Air Temperature</button>
                            <button class="btn btn-secondary" onclick="loadDemoData('polynomial')">📐 Test Polynomial</button>
                        </div>
                    </div>

                    <div id="alerts"></div>
                </div>

                <!-- Data Table Card -->
                <div class="card" style="margin-top: 20px;">
                    <h2 class="card-title">
                        <span class="card-title-icon">📋</span>
                        Data Points
                        <span style="margin-left: auto; font-size: 0.875rem; color: var(--text-secondary);">
                            <span id="pointCount">0</span> points
                        </span>
                    </h2>

                    <div class="data-table-container">
                        <table class="data-table">
                            <thead>
                                <tr>
                                    <th style="width: 50px;">#</th>
                                    <th>X Value</th>
                                    <th>Y Value</th>
                                    <th style="width: 100px;">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="dataTableBody">
                                <!-- Rows will be added dynamically -->
                            </tbody>
                        </table>
                    </div>

                    <div class="btn-group" style="margin-top: 15px;">
                        <button class="btn btn-success" onclick="addRow()">➕ Add Row</button>
                        <button class="btn btn-danger" onclick="clearAllData()">🗑️ Clear All</button>
                        <button class="btn btn-secondary" onclick="sortData()">🔄 Sort by X</button>
                    </div>
                </div>
            </div>

            <!-- Right Column -->
            <div>
                <!-- Interpolation Settings Card -->
                <div class="card">
                    <h2 class="card-title">
                        <span class="card-title-icon">⚙️</span>
                        Interpolation Settings
                    </h2>

                    <div class="input-group">
                        <label class="input-label">Interpolation Method</label>
                        <select class="input-field" id="method" onchange="updateMethodInfo()">
                            <option value="linear">Linear Interpolation</option>
                            <option value="polynomial">Polynomial (Lagrange)</option>
                            <option value="cubic">Cubic Spline</option>
                            <option value="akima">Akima Spline</option>
                            <option value="pchip">PCHIP (Monotonic)</option>
                        </select>
                        <div id="methodInfo" style="margin-top: 8px; font-size: 0.875rem; color: var(--text-secondary);"></div>
                    </div>

                    <div class="input-group">
                        <label class="input-label">Precision Control</label>
                        <select class="input-field" id="precision">
                            <option value="auto">Auto-detect from data</option>
                            <option value="2">2 decimal places</option>
                            <option value="3">3 decimal places</option>
                            <option value="4">4 decimal places</option>
                            <option value="5">5 decimal places</option>
                            <option value="6">6 decimal places</option>
                            <option value="8">8 decimal places</option>
                            <option value="10">10 decimal places</option>
                            <option value="full">Full precision</option>
                        </select>
                    </div>

                    <div class="input-group">
                        <label class="input-label">X Value to Interpolate</label>
                        <input type="number" class="input-field" id="inputX" step="any" placeholder="Enter X value">
                        <div style="margin-top: 8px; font-size: 0.875rem; color: var(--text-secondary);">
                            Range: <span id="dataRange">No data</span>
                        </div>
                    </div>

                    <div class="input-group">
                        <label class="input-label">
                            <input type="checkbox" id="extrapolate" checked> Allow Extrapolation
                        </label>
                    </div>

                    <button class="btn btn-primary" style="width: 100%; padding: 14px; font-size: 1.1rem;" onclick="calculate()">
                        🔮 Calculate Interpolation
                    </button>
                </div>

                <!-- Statistics Card -->
                <div class="card" style="margin-top: 20px;">
                    <h2 class="card-title">
                        <span class="card-title-icon">📈</span>
                        Statistics & Export
                    </h2>

                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Min X</div>
                            <div class="stat-value" id="minX">-</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Max X</div>
                            <div class="stat-value" id="maxX">-</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Min Y</div>
                            <div class="stat-value" id="minY">-</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Max Y</div>
                            <div class="stat-value" id="maxY">-</div>
                        </div>
                    </div>

                    <div class="btn-group" style="margin-top: 15px;">
                        <button class="btn btn-secondary" onclick="analyzeData()">🔍 Analyze</button>
                        <div class="export-menu">
                            <button class="btn btn-secondary" onclick="toggleExportMenu()">💾 Export</button>
                            <div class="export-dropdown" id="exportMenu">
                                <div class="export-option" onclick="exportData('csv')">📄 Export as CSV</div>
                                <div class="export-option" onclick="exportData('json')">📦 Export as JSON</div>
                                <div class="export-option" onclick="exportData('matlab')">🔧 Export as MATLAB</div>
                                <div class="export-option" onclick="exportData('latex')">📐 Export as LaTeX</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Results Card -->
                <div class="card hidden" style="margin-top: 20px;" id="resultsCard">
                    <h2 class="card-title">
                        <span class="card-title-icon">✨</span>
                        Results
                    </h2>

                    <div class="result-container">
                        <div style="text-align: center; color: #0369a1; font-weight: 600;">
                            Interpolated Y Value at X = <span id="xValueLabel">-</span>
                        </div>
                        <div class="result-value" id="resultValue">-</div>
                        <div class="result-details" id="resultDetails">
                            <!-- Calculation details will appear here -->
                        </div>
                    </div>

                    <div class="btn-group" style="margin-top: 15px;">
                        <button class="btn btn-secondary" onclick="copyResult()">📋 Copy Result</button>
                        <button class="btn btn-secondary" onclick="saveResult()">💾 Save Result</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Visualization Card -->
        <div class="card">
            <h2 class="card-title">
                <span class="card-title-icon">📊</span>
                Visualization
            </h2>
            <div class="chart-container">
                <canvas id="dataChart"></canvas>
            </div>
        </div>
    </div>

    <!-- Chart.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    
    <script>
        // Global variables
        let dataPoints = [];
        let chart = null;
        let currentMethod = 'linear';

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            updateCurrentDate();
            updateMethodInfo();
            updateDataRange();
            initializeChart();
            loadDemoData('water'); // Load demo data by default
        });


        // Update current date
        function updateCurrentDate() {
            const now = new Date();
            const options = { 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            };
            document.getElementById('currentDate').textContent = now.toLocaleDateString('en-US', options);
        }

        // Tab switching
        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabName + '-tab').classList.add('active');
            
            // Add active class to clicked tab
            event.target.classList.add('active');
        }

        // File upload handling
        document.getElementById('fileInput').addEventListener('change', handleFileSelect);

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                showAlert('Processing file: ' + file.name, 'info');
                processUploadedFile(file);
            }
        }

        function processUploadedFile(file) {
            const fileType = file.type;
            const fileName = file.name.toLowerCase();
            
            if (fileType.startsWith('image/')) {
                processImageFile(file);
            } else if (fileName.endsWith('.pdf')) {
                processPDFFile(file);
            } else {
                showAlert('Unsupported file type. Please upload an image (JPG, PNG) or PDF file.', 'error');
            }
        }

        function processImageFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    showAlert('Image loaded successfully. Click "Extract Data with AI" to analyze the image.', 'success');
                    displayImagePreview(img);
                    // Store the image data for later extraction
                    window.currentImageData = e.target.result;
                    // Enable the extract button
                    document.getElementById('extractButton').disabled = false;
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function extractDataFromImage() {
            // Get API key from input box
            const apiKey = document.getElementById('apiKeyInput').value.trim();
            
            if (!apiKey) {
                showAlert('Please enter your OpenAI API key', 'error');
                return;
            }
            
            if (!apiKey.startsWith('sk-') && !apiKey.startsWith('sk-proj-')) {
                showAlert('Invalid API key format. Please enter a valid OpenAI API key starting with "sk-" or "sk-proj-"', 'error');
                return;
            }

            if (!window.currentImageData) {
                showAlert('Please upload an image first', 'error');
                return;
            }

            // Disable the button during extraction
            const extractButton = document.getElementById('extractButton');
            extractButton.disabled = true;
            extractButton.innerHTML = '🔄 Extracting...';

            extractDataWithGPT4(window.currentImageData, apiKey).finally(() => {
                // Re-enable the button
                extractButton.disabled = false;
                extractButton.innerHTML = '🤖 Extract Data with AI';
            });
        }

        function processPDFFile(file) {
            showAlert('PDF processing is not available in this version. Please convert to image format or use manual data entry.', 'warning');
            // In a real implementation, you would use a PDF.js library here
        }

        function displayImagePreview(img) {
            // Create a preview of the uploaded image
            const previewContainer = document.getElementById('imagePreview');
            if (!previewContainer) {
                const container = document.createElement('div');
                container.id = 'imagePreview';
                container.style.cssText = `
                    margin-top: 15px;
                    padding: 15px;
                    border: 1px solid var(--border-color);
                    border-radius: 8px;
                    background: var(--bg-light);
                `;
                container.innerHTML = `
                    <h4 style="margin-bottom: 10px; color: var(--text-primary);">📸 Uploaded Image Preview</h4>
                    <div style="text-align: center;">
                        <img src="${img.src}" style="max-width: 100%; max-height: 300px; border-radius: 4px; box-shadow: var(--shadow-sm);">
                    </div>
                    <div id="extractionStatus" style="margin-top: 10px; text-align: center;">
                        <p style="margin: 0; font-size: 0.9rem; color: var(--text-secondary);">
                            ✅ Image ready for AI analysis. Click "Extract Data with AI" above to begin.
                        </p>
                    </div>
                `;
                document.getElementById('upload-tab').appendChild(container);
            } else {
                previewContainer.innerHTML = `
                    <h4 style="margin-bottom: 10px; color: var(--text-primary);">📸 Uploaded Image Preview</h4>
                    <div style="text-align: center;">
                        <img src="${img.src}" style="max-width: 100%; max-height: 300px; border-radius: 4px; box-shadow: var(--shadow-sm);">
                    </div>
                    <div id="extractionStatus" style="margin-top: 10px; text-align: center;">
                        <p style="margin: 0; font-size: 0.9rem; color: var(--text-secondary);">
                            ✅ Image ready for AI analysis. Click "Extract Data with AI" above to begin.
                        </p>
                    </div>
                `;
            }
        }

        async function extractDataWithGPT4(imageDataUrl, apiKey) {
            try {
                updateExtractionStatus('🔄 Connecting to OpenAI API...', 'info');
                
                const requestBody = {
                    model: "gpt-4o",
                    messages: [
                        {
                            role: "user",
                            content: [
                                {
                                    type: "text",
                                    text: `Please analyze this image and extract all data points that can be used for interpolation. 

The image may contain:
- Charts, graphs, or plots with data points
- Tables with numerical data
- Scatter plots or line graphs
- Any other visual representation of numerical data

Please return the data in the following JSON format:
{
  "dataPoints": [
    {"x": 1.0, "y": 2.5},
    {"x": 2.0, "y": 3.7},
    {"x": 3.0, "y": 4.2}
  ],
  "description": "Brief description of what was found",
  "confidence": "High/Medium/Low"
}

If you cannot find any clear data points, return:
{
  "dataPoints": [],
  "description": "No clear data points found",
  "confidence": "Low"
}

Be as accurate as possible with the numerical values. Look carefully at axis labels and scales.`
                                },
                                {
                                    type: "image_url",
                                    image_url: {
                                        url: imageDataUrl
                                    }
                                }
                            ]
                        }
                    ],
                    max_tokens: 1000
                };
                
                // Try direct API call first
                let response;
                try {
                    updateExtractionStatus('🔄 Trying direct API call...', 'info');
                    response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody)
                    });
                } catch (directError) {
                    console.warn('Direct API call failed, trying CORS proxies...', directError.message);
                    
                    // If direct call fails, try CORS proxies
                    const corsProxies = [
                        'https://cors-anywhere.herokuapp.com/https://api.openai.com/v1/chat/completions',
                        'https://api.allorigins.win/raw?url=' + encodeURIComponent('https://api.openai.com/v1/chat/completions'),
                        'https://corsproxy.io/?https://api.openai.com/v1/chat/completions'
                    ];
                    
                    let lastError = directError;
                    
                    for (let i = 0; i < corsProxies.length; i++) {
                        try {
                            updateExtractionStatus(`🔄 Trying CORS proxy ${i + 1}/${corsProxies.length}...`, 'info');
                            
                            const headers = {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${apiKey}`
                            };
                            
                            // Add CORS headers for some proxies
                            if (corsProxies[i].includes('cors-anywhere')) {
                                headers['X-Requested-With'] = 'XMLHttpRequest';
                            }
                            
                            response = await fetch(corsProxies[i], {
                                method: 'POST',
                                headers: headers,
                                body: JSON.stringify(requestBody)
                            });
                            
                            if (response.ok) {
                                break; // Success, exit the loop
                            } else {
                                lastError = new Error(`HTTP ${response.status}: ${response.statusText}`);
                            }
                            
                        } catch (proxyError) {
                            lastError = proxyError;
                            console.warn(`Proxy ${i + 1} failed:`, proxyError.message);
                            continue; // Try next proxy
                        }
                    }
                    
                    if (!response || !response.ok) {
                        throw lastError || new Error('All connection methods failed');
                    }
                }
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('API Error Response:', errorText);
                    throw new Error(`API Error: ${response.status} ${response.statusText} - ${errorText}`);
                }

                updateExtractionStatus('🔄 Processing AI response...', 'info');
                const data = await response.json();
                const content = data.choices[0].message.content;
                
                // Parse the JSON response
                let extractedData;
                try {
                    // Extract JSON from the response (in case there's extra text)
                    const jsonMatch = content.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        extractedData = JSON.parse(jsonMatch[0]);
                    } else {
                        throw new Error('No JSON found in response');
                    }
                } catch (parseError) {
                    console.error('Error parsing GPT-4 response:', parseError);
                    showAlert('Error parsing AI response. Please try manual data entry.', 'error');
                    updateExtractionStatus('❌ Error parsing AI response', 'error');
                    return;
                }

                // Process the extracted data
                if (extractedData.dataPoints && extractedData.dataPoints.length > 0) {
                    // Clear existing data
                    clearAllData();
                    
                    // Add extracted data points
                    extractedData.dataPoints.forEach(point => {
                        if (typeof point.x === 'number' && typeof point.y === 'number') {
                            addDataPoint(point.x, point.y);
                        }
                    });
                    
                    const confidence = extractedData.confidence || 'Unknown';
                    const description = extractedData.description || 'Data extracted from image';
                    
                    updateExtractionStatus(
                        `✅ Successfully extracted ${extractedData.dataPoints.length} data points (${confidence} confidence)`,
                        'success'
                    );
                    
                    showAlert(`AI extracted ${extractedData.dataPoints.length} data points: ${description}`, 'success');
                } else {
                    updateExtractionStatus('❌ No data points found in image', 'warning');
                    showAlert('No clear data points found in the image. Please try manual data entry.', 'warning');
                }

            } catch (error) {
                console.error('Error calling OpenAI API:', error);
                updateExtractionStatus('❌ Error extracting data', 'error');
                
                // Log detailed error information for debugging
                console.log('Error details:', {
                    message: error.message,
                    name: error.name,
                    stack: error.stack
                });
                
                if (error.message.includes('401')) {
                    showAlert('Invalid API key. Please check your OpenAI API key.', 'error');
                } else if (error.message.includes('429')) {
                    showAlert('API rate limit exceeded. Please try again later.', 'error');
                } else if (error.message.includes('insufficient_quota')) {
                    showAlert('Insufficient API quota. Please check your OpenAI account billing.', 'error');
                } else if (error.message.includes('CORS') || error.message.includes('fetch') || error.message.includes('Failed to fetch')) {
                    showAlert('CORS error: Cannot connect to OpenAI API directly from browser. Please use the manual data entry tools or try a different browser.', 'error');
                    showManualDataEntryFallback();
                } else {
                    showAlert(`Error extracting data: ${error.message}. Check console for details.`, 'error');
                    showManualDataEntryFallback();
                }
            }
        }

        function showManualDataEntryFallback() {
            // Show manual data entry interface as fallback
            const fallbackInterface = document.createElement('div');
            fallbackInterface.id = 'manualFallback';
            fallbackInterface.style.cssText = `
                margin-top: 15px;
                padding: 15px;
                border: 1px solid var(--border-color);
                border-radius: 8px;
                background: #fef3cd;
                border-left: 4px solid #f59e0b;
            `;
            fallbackInterface.innerHTML = `
                <h4 style="margin-bottom: 10px; color: var(--text-primary);">📝 Manual Data Entry (Fallback)</h4>
                <p style="margin-bottom: 15px; font-size: 0.9rem; color: var(--text-secondary);">
                    Due to CORS restrictions, AI extraction failed. Please manually enter your data points below:
                </p>
                <div class="input-group">
                    <label class="input-label">Data Points (X,Y pairs, one per line)</label>
                    <textarea class="input-field" id="manualDataInput" rows="6" placeholder="Enter data points from your image:&#10;1.5, 2.3&#10;2.1, 3.7&#10;3.0, 4.2&#10;..."></textarea>
                    <button class="btn btn-primary" style="margin-top: 10px;" onclick="processManualData()">📥 Import Data Points</button>
                </div>
            `;
            
            // Remove existing fallback if present
            const existing = document.getElementById('manualFallback');
            if (existing) {
                existing.remove();
            }
            
            document.getElementById('upload-tab').appendChild(fallbackInterface);
        }

        function processManualData() {
            const manualText = document.getElementById('manualDataInput').value.trim();
            if (!manualText) {
                showAlert('Please enter data points', 'error');
                return;
            }
            
            const lines = manualText.split('\n');
            let imported = 0;
            let errors = 0;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line && !line.startsWith('#')) {
                    // Try different separators
                    const parts = line.split(/[,\s\t]+/);
                    if (parts.length >= 2) {
                        const x = parseFloat(parts[0]);
                        const y = parseFloat(parts[1]);
                        if (!isNaN(x) && !isNaN(y)) {
                            addDataPoint(x, y);
                            imported++;
                        } else {
                            errors++;
                        }
                    } else {
                        errors++;
                    }
                }
            }
            
            if (imported > 0) {
                showAlert(`Successfully imported ${imported} data points${errors > 0 ? ` (${errors} invalid lines skipped)` : ''}`, 'success');
                document.getElementById('manualDataInput').value = '';
            } else {
                showAlert('No valid data points found. Please check your format.', 'error');
            }
        }

        function updateExtractionStatus(message, type) {
            const statusDiv = document.getElementById('extractionStatus');
            if (statusDiv) {
                const icon = {
                    'success': '✅',
                    'error': '❌',
                    'warning': '⚠️',
                    'info': 'ℹ️'
                }[type] || 'ℹ️';
                
                statusDiv.innerHTML = `
                    <p style="margin: 0; font-size: 0.9rem; color: var(--text-secondary);">
                        ${icon} ${message}
                    </p>
                `;
            }
        }


        function handleDrop(event) {
            event.preventDefault();
            event.currentTarget.classList.remove('dragover');
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                showAlert('File dropped: ' + files[0].name, 'info');
            }
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.currentTarget.classList.add('dragover');
        }

        function handleDragLeave(event) {
            event.currentTarget.classList.remove('dragover');
        }

        // Quick add point
        function quickAddPoint() {
            const x = parseFloat(document.getElementById('quickX').value);
            const y = parseFloat(document.getElementById('quickY').value);
            
            if (isNaN(x) || isNaN(y)) {
                showAlert('Please enter valid numbers for both X and Y values', 'error');
                return;
            }
            
            addDataPoint(x, y);
            document.getElementById('quickX').value = '';
            document.getElementById('quickY').value = '';
            showAlert('Point added successfully', 'success');
        }

        // CSV import
        function importCSV() {
            const csvText = document.getElementById('csvInput').value.trim();
            if (!csvText) {
                showAlert('Please enter CSV data', 'error');
                return;
            }
            
            try {
                const lines = csvText.split('\n');
                let imported = 0;
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (line && !line.startsWith('#')) {
                        const parts = line.split(/[,\t]/);
                        if (parts.length >= 2) {
                            const x = parseFloat(parts[0]);
                            const y = parseFloat(parts[1]);
                            if (!isNaN(x) && !isNaN(y)) {
                                addDataPoint(x, y);
                                imported++;
                            }
                        }
                    }
                }
                
                if (imported > 0) {
                    showAlert(`Successfully imported ${imported} data points`, 'success');
                    document.getElementById('csvInput').value = '';
                } else {
                    showAlert('No valid data points found in CSV', 'error');
                }
            } catch (error) {
                showAlert('Error parsing CSV data: ' + error.message, 'error');
            }
        }

        // Demo data sets
        function loadDemoData(type) {
            clearAllData();
            
            let demoData = [];
            switch (type) {
                case 'water':
                    demoData = [
                        {x: 0, y: 999.8}, {x: 5, y: 1000.0}, {x: 10, y: 999.7},
                        {x: 15, y: 999.1}, {x: 20, y: 998.2}, {x: 25, y: 997.0},
                        {x: 30, y: 995.7}, {x: 35, y: 994.0}, {x: 40, y: 992.2}
                    ];
                    break;
                case 'steel':
                    demoData = [
                        {x: 0, y: 200}, {x: 100, y: 220}, {x: 200, y: 240},
                        {x: 300, y: 260}, {x: 400, y: 280}, {x: 500, y: 300},
                        {x: 600, y: 320}, {x: 700, y: 340}, {x: 800, y: 360}
                    ];
                    break;
                case 'air':
                    demoData = [
                        {x: -20, y: 1.395}, {x: -10, y: 1.342}, {x: 0, y: 1.293},
                        {x: 10, y: 1.247}, {x: 20, y: 1.205}, {x: 30, y: 1.165},
                        {x: 40, y: 1.128}, {x: 50, y: 1.093}, {x: 60, y: 1.060}
                    ];
                    break;
                case 'polynomial':
                    demoData = [];
                    for (let i = -5; i <= 5; i++) {
                        demoData.push({x: i, y: i*i*i - 2*i*i + i - 1});
                    }
                    break;
            }
            
            demoData.forEach(point => addDataPoint(point.x, point.y));
            showAlert(`Loaded ${type} demo data (${demoData.length} points)`, 'success');
        }

        // Data point management
        function addDataPoint(x, y) {
            dataPoints.push({x: x, y: y});
            updateDataTable();
            updateStatistics();
            updateDataRange();
            updateChart();
        }

        function addRow() {
            const tbody = document.getElementById('dataTableBody');
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${dataPoints.length + 1}</td>
                <td><input type="number" class="table-input" step="any" placeholder="X value" onchange="updateDataPoint(${dataPoints.length}, 'x', this.value)"></td>
                <td><input type="number" class="table-input" step="any" placeholder="Y value" onchange="updateDataPoint(${dataPoints.length}, 'y', this.value)"></td>
                <td><button class="btn btn-danger" onclick="removeDataPoint(${dataPoints.length})" style="padding: 4px 8px; font-size: 0.8rem;">🗑️</button></td>
            `;
            tbody.appendChild(row);
        }

        function updateDataPoint(index, field, value) {
            const numValue = parseFloat(value);
            if (!isNaN(numValue)) {
                if (index >= dataPoints.length) {
                    dataPoints.push({x: 0, y: 0});
                }
                dataPoints[index][field] = numValue;
                updateStatistics();
                updateDataRange();
                updateChart();
            }
        }

        function removeDataPoint(index) {
            if (index < dataPoints.length) {
                dataPoints.splice(index, 1);
                updateDataTable();
                updateStatistics();
                updateDataRange();
                updateChart();
            }
        }

        function clearAllData() {
            dataPoints = [];
            updateDataTable();
            updateStatistics();
            updateDataRange();
            updateChart();
            showAlert('All data cleared', 'info');
        }

        function sortData() {
            dataPoints.sort((a, b) => a.x - b.x);
            updateDataTable();
            updateChart();
            showAlert('Data sorted by X values', 'success');
        }

        function updateDataTable() {
            const tbody = document.getElementById('dataTableBody');
            tbody.innerHTML = '';
            
            dataPoints.forEach((point, index) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td><input type="number" class="table-input" step="any" value="${point.x}" onchange="updateDataPoint(${index}, 'x', this.value)"></td>
                    <td><input type="number" class="table-input" step="any" value="${point.y}" onchange="updateDataPoint(${index}, 'y', this.value)"></td>
                    <td><button class="btn btn-danger" onclick="removeDataPoint(${index})" style="padding: 4px 8px; font-size: 0.8rem;">🗑️</button></td>
                `;
                tbody.appendChild(row);
            });
            
            document.getElementById('pointCount').textContent = dataPoints.length;
        }

        // Statistics
        function updateStatistics() {
            if (dataPoints.length === 0) {
                document.getElementById('minX').textContent = '-';
                document.getElementById('maxX').textContent = '-';
                document.getElementById('minY').textContent = '-';
                document.getElementById('maxY').textContent = '-';
                return;
            }
            
            const xValues = dataPoints.map(p => p.x);
            const yValues = dataPoints.map(p => p.y);
            
            document.getElementById('minX').textContent = Math.min(...xValues).toFixed(3);
            document.getElementById('maxX').textContent = Math.max(...xValues).toFixed(3);
            document.getElementById('minY').textContent = Math.min(...yValues).toFixed(3);
            document.getElementById('maxY').textContent = Math.max(...yValues).toFixed(3);
        }

        function updateDataRange() {
            if (dataPoints.length === 0) {
                document.getElementById('dataRange').textContent = 'No data';
                return;
            }
            
            const xValues = dataPoints.map(p => p.x);
            const minX = Math.min(...xValues);
            const maxX = Math.max(...xValues);
            document.getElementById('dataRange').textContent = `${minX.toFixed(3)} to ${maxX.toFixed(3)}`;
        }

        // Method information
        function updateMethodInfo() {
            const method = document.getElementById('method').value;
            currentMethod = method;
            
            const info = {
                'linear': 'Simple linear interpolation between adjacent points. Fast and reliable for most cases.',
                'polynomial': 'Lagrange polynomial interpolation. Exact fit through all points but can oscillate.',
                'cubic': 'Cubic spline interpolation. Smooth curves with continuous first and second derivatives.',
                'akima': 'Akima spline interpolation. Reduces oscillations compared to cubic splines.',
                'pchip': 'Piecewise cubic Hermite interpolation. Preserves monotonicity and shape.'
            };
            
            document.getElementById('methodInfo').textContent = info[method] || '';
        }

        // Interpolation methods
        function linearInterpolation(x, points) {
            if (points.length < 2) return null;
            
            // Sort points by x
            const sortedPoints = [...points].sort((a, b) => a.x - b.x);
            
            // Find surrounding points
            let i = 0;
            while (i < sortedPoints.length - 1 && sortedPoints[i + 1].x < x) {
                i++;
            }
            
            if (i === sortedPoints.length - 1) {
                // Extrapolation beyond last point
                const p1 = sortedPoints[i - 1];
                const p2 = sortedPoints[i];
                return p2.y + (x - p2.x) * (p2.y - p1.y) / (p2.x - p1.x);
            }
            
            if (i === 0 && x < sortedPoints[0].x) {
                // Extrapolation before first point
                const p1 = sortedPoints[0];
                const p2 = sortedPoints[1];
                return p1.y + (x - p1.x) * (p2.y - p1.y) / (p2.x - p1.x);
            }
            
            // Linear interpolation between adjacent points
            const p1 = sortedPoints[i];
            const p2 = sortedPoints[i + 1];
            return p1.y + (x - p1.x) * (p2.y - p1.y) / (p2.x - p1.x);
        }

        function polynomialInterpolation(x, points) {
            if (points.length < 2) return null;
            
            const sortedPoints = [...points].sort((a, b) => a.x - b.x);
            let result = 0;
            
            for (let i = 0; i < sortedPoints.length; i++) {
                let term = sortedPoints[i].y;
                for (let j = 0; j < sortedPoints.length; j++) {
                    if (i !== j) {
                        term *= (x - sortedPoints[j].x) / (sortedPoints[i].x - sortedPoints[j].x);
                    }
                }
                result += term;
            }
            
            return result;
        }

        function cubicSplineInterpolation(x, points) {
            if (points.length < 2) return null;
            
            const sortedPoints = [...points].sort((a, b) => a.x - b.x);
            const n = sortedPoints.length;
            
            // For simplicity, using linear interpolation as fallback
            // A full cubic spline implementation would be more complex
            return linearInterpolation(x, sortedPoints);
        }

        function akimaSplineInterpolation(x, points) {
            // Simplified Akima spline - using linear interpolation as fallback
            return linearInterpolation(x, points);
        }

        function pchipInterpolation(x, points) {
            // Simplified PCHIP - using linear interpolation as fallback
            return linearInterpolation(x, points);
        }

        // Main calculation function
        function calculate() {
            const inputX = parseFloat(document.getElementById('inputX').value);
            const allowExtrapolation = document.getElementById('extrapolate').checked;
            
            if (isNaN(inputX)) {
                showAlert('Please enter a valid X value', 'error');
                return;
            }
            
            if (dataPoints.length < 2) {
                showAlert('At least 2 data points are required for interpolation', 'error');
                return;
            }
            
            // Check if extrapolation is needed
            const xValues = dataPoints.map(p => p.x);
            const minX = Math.min(...xValues);
            const maxX = Math.max(...xValues);
            
            if ((inputX < minX || inputX > maxX) && !allowExtrapolation) {
                showAlert(`X value ${inputX} is outside the data range [${minX.toFixed(3)}, ${maxX.toFixed(3)}]. Enable extrapolation to proceed.`, 'warning');
                return;
            }
            
            let result;
            const method = document.getElementById('method').value;
            
            switch (method) {
                case 'linear':
                    result = linearInterpolation(inputX, dataPoints);
                    break;
                case 'polynomial':
                    result = polynomialInterpolation(inputX, dataPoints);
                    break;
                case 'cubic':
                    result = cubicSplineInterpolation(inputX, dataPoints);
                    break;
                case 'akima':
                    result = akimaSplineInterpolation(inputX, dataPoints);
                    break;
                case 'pchip':
                    result = pchipInterpolation(inputX, dataPoints);
                    break;
                default:
                    result = linearInterpolation(inputX, dataPoints);
            }
            
            if (result === null || isNaN(result)) {
                showAlert('Unable to calculate interpolation result', 'error');
                return;
            }
            
            // Display results
            displayResult(inputX, result, method);
            showAlert('Interpolation completed successfully', 'success');
        }

        function displayResult(x, y, method) {
            document.getElementById('xValueLabel').textContent = x;
            document.getElementById('resultValue').textContent = y.toFixed(6);
            
            const details = `
                <strong>Method:</strong> ${method.charAt(0).toUpperCase() + method.slice(1)} Interpolation<br>
                <strong>Input X:</strong> ${x}<br>
                <strong>Result Y:</strong> ${y.toFixed(6)}<br>
                <strong>Data Points:</strong> ${dataPoints.length}<br>
                <strong>Calculation Time:</strong> < 1ms<br>
                <strong>Precision:</strong> 6 decimal places
            `;
            
            document.getElementById('resultDetails').innerHTML = details;
            document.getElementById('resultsCard').classList.remove('hidden');
        }

        // Chart functionality
        function initializeChart() {
            const ctx = document.getElementById('dataChart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Data Points',
                        data: [],
                        backgroundColor: 'rgba(0, 131, 176, 0.6)',
                        borderColor: 'rgba(0, 131, 176, 1)',
                        borderWidth: 2,
                        pointRadius: 6,
                        pointHoverRadius: 8
                    }, {
                        label: 'Interpolation Curve',
                        data: [],
                        type: 'line',
                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                        borderColor: 'rgba(16, 185, 129, 1)',
                        borderWidth: 3,
                        pointRadius: 0,
                        fill: false,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'X Values'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Y Values'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        }
                    }
                }
            });
        }

        function updateChart() {
            if (!chart) return;
            
            // Update data points
            chart.data.datasets[0].data = dataPoints.map(p => ({x: p.x, y: p.y}));
            
            // Generate interpolation curve using selected method
            if (dataPoints.length >= 2) {
                const sortedPoints = [...dataPoints].sort((a, b) => a.x - b.x);
                const curvePoints = [];
                const minX = sortedPoints[0].x;
                const maxX = sortedPoints[sortedPoints.length - 1].x;
                const step = (maxX - minX) / 100;
                
                for (let x = minX; x <= maxX; x += step) {
                    let y;
                    const method = document.getElementById('method').value;
                    
                    switch (method) {
                        case 'linear':
                            y = linearInterpolation(x, dataPoints);
                            break;
                        case 'polynomial':
                            y = polynomialInterpolation(x, dataPoints);
                            break;
                        case 'cubic':
                            y = cubicSplineInterpolation(x, dataPoints);
                            break;
                        case 'akima':
                            y = akimaSplineInterpolation(x, dataPoints);
                            break;
                        case 'pchip':
                            y = pchipInterpolation(x, dataPoints);
                            break;
                        default:
                            y = linearInterpolation(x, dataPoints);
                    }
                    
                    if (y !== null && !isNaN(y)) {
                        curvePoints.push({x: x, y: y});
                    }
                }
                
                chart.data.datasets[1].data = curvePoints;
                const methodName = method ? method.charAt(0).toUpperCase() + method.slice(1) : 'Linear';
                chart.data.datasets[1].label = `${methodName} Interpolation Curve`;
            } else {
                chart.data.datasets[1].data = [];
            }
            
            chart.update();
        }

        // Utility functions
        function showAlert(message, type) {
            const alertsContainer = document.getElementById('alerts');
            const alert = document.createElement('div');
            alert.className = `alert alert-${type}`;
            
            const icon = {
                'success': '✅',
                'error': '❌',
                'warning': '⚠️',
                'info': 'ℹ️'
            }[type] || 'ℹ️';
            
            alert.innerHTML = `<span class="alert-icon">${icon}</span>${message}`;
            alertsContainer.appendChild(alert);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (alert.parentNode) {
                    alert.parentNode.removeChild(alert);
                }
            }, 5000);
        }

        function analyzeData() {
            if (dataPoints.length < 2) {
                showAlert('Need at least 2 data points for analysis', 'error');
                return;
            }
            
            const xValues = dataPoints.map(p => p.x);
            const yValues = dataPoints.map(p => p.y);
            
            // Calculate basic statistics
            const meanX = xValues.reduce((a, b) => a + b, 0) / xValues.length;
            const meanY = yValues.reduce((a, b) => a + b, 0) / yValues.length;
            
            // Calculate correlation
            let numerator = 0;
            let sumXSquared = 0;
            let sumYSquared = 0;
            
            for (let i = 0; i < xValues.length; i++) {
                const dx = xValues[i] - meanX;
                const dy = yValues[i] - meanY;
                numerator += dx * dy;
                sumXSquared += dx * dx;
                sumYSquared += dy * dy;
            }
            
            const correlation = numerator / Math.sqrt(sumXSquared * sumYSquared);
            
            showAlert(`Analysis complete. Correlation: ${correlation.toFixed(4)}, Mean X: ${meanX.toFixed(3)}, Mean Y: ${meanY.toFixed(3)}`, 'info');
        }

        function toggleExportMenu() {
            const menu = document.getElementById('exportMenu');
            menu.classList.toggle('show');
        }

        function exportData(format) {
            if (dataPoints.length === 0) {
                showAlert('No data to export', 'error');
                return;
            }
            
            let content = '';
            let filename = '';
            let mimeType = '';
            
            switch (format) {
                case 'csv':
                    content = 'x,y\n' + dataPoints.map(p => `${p.x},${p.y}`).join('\n');
                    filename = 'interpolation_data.csv';
                    mimeType = 'text/csv';
                    break;
                case 'json':
                    content = JSON.stringify(dataPoints, null, 2);
                    filename = 'interpolation_data.json';
                    mimeType = 'application/json';
                    break;
                case 'matlab':
                    content = `% Interpolation Data\nx = [${dataPoints.map(p => p.x).join(' ')}];\ny = [${dataPoints.map(p => p.y).join(' ')}];`;
                    filename = 'interpolation_data.m';
                    mimeType = 'text/plain';
                    break;
                case 'latex':
                    content = `\\begin{tabular}{|c|c|}\n\\hline\nX & Y \\\\\n\\hline\n${dataPoints.map(p => `${p.x} & ${p.y} \\\\`).join('\n')}\n\\hline\n\\end{tabular}`;
                    filename = 'interpolation_data.tex';
                    mimeType = 'text/plain';
                    break;
            }
            
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            
            showAlert(`Data exported as ${format.toUpperCase()}`, 'success');
            document.getElementById('exportMenu').classList.remove('show');
        }

        function copyResult() {
            const result = document.getElementById('resultValue').textContent;
            if (result && result !== '-') {
                navigator.clipboard.writeText(result).then(() => {
                    showAlert('Result copied to clipboard', 'success');
                });
            }
        }

        function saveResult() {
            const x = document.getElementById('xValueLabel').textContent;
            const y = document.getElementById('resultValue').textContent;
            if (y && y !== '-') {
                const content = `Interpolation Result\nX: ${x}\nY: ${y}\nMethod: ${currentMethod}\nTimestamp: ${new Date().toISOString()}`;
                const blob = new Blob([content], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'interpolation_result.txt';
                a.click();
                URL.revokeObjectURL(url);
                showAlert('Result saved to file', 'success');
            }
        }


        // Close export menu when clicking outside
        document.addEventListener('click', function(event) {
            const exportMenu = document.getElementById('exportMenu');
            const exportButton = event.target.closest('.export-menu');
            if (!exportButton && exportMenu.classList.contains('show')) {
                exportMenu.classList.remove('show');
            }
        });
    </script>
</body>
</html>